Project Path: src

Source Tree:

```txt
src
â”œâ”€â”€ bot.ts
â”œâ”€â”€ core.ts
â”œâ”€â”€ generateEmbeddings.ts
â”œâ”€â”€ main.ts
â”œâ”€â”€ prompts.ts
â”œâ”€â”€ schema.ts
â””â”€â”€ tools.ts

```

`src/bot.ts`:

```ts
import 'dotenv/config';

import { z } from 'zod';
import { Bot } from 'grammy';
import got from 'got';
import { ok } from 'assert';
import { pipeline } from 'stream/promises';
import { createId } from '@paralleldrive/cuid2';
import { createWriteStream, existsSync, mkdirSync } from 'fs';
import { readdir, readFile, rm } from 'fs/promises';
import { join } from 'path';
import { Poppler } from 'node-poppler';
import OpenAI from 'openai';
import { db, llm, type MessageContent } from './core.js';
import type { JobPostingsDetails } from '../types.js';

type SimilarityResult = JobPostingsDetails & { similarity: number };

type FileResult = {
    result?: {
        file_path?: string;
    };
};

const { BOT_TOKEN } = process.env;

ok(BOT_TOKEN, 'BOT_TOKEN MUST BE DEFINED');

const baseDir = join(process.cwd(), 'tmp');

const DocumentMessageSchema = z.object({
    message: z.object({
        document: z.object({
            file_id: z.string(),
            file_name: z.string().optional(),
            mime_type: z.string().optional(),
            file_size: z.number().optional(),
        }),
    }),
});

export const bot = new Bot(BOT_TOKEN);
const poppler = new Poppler();

const embeder = new OpenAI();

bot.command('start', (ctx) =>
    ctx.reply(
        'Welcome to the Matcher. I am here to help you find your pefect job matches! Please provide your resume in PDF format to begin!'
    )
);
// bot.on('message', (ctx) => ctx.reply('Got another message!'));
bot.on(':document', async (ctx) => {
    const result = DocumentMessageSchema.safeParse(ctx.update);

    if (!result.success) {
        return ctx.reply('there was a problem with your request');
    }
    console.log(ctx.update);
    const document = result.data.message.document;
    console.log('Received document:', document.file_id);

    try {
        const getFileUrl = `https://api.telegram.org/bot${BOT_TOKEN}/getFile?file_id=${document.file_id}`;
        const fileUrl = (await got.get(getFileUrl).json()) as FileResult;

        ok(fileUrl.result);

        const tempDir = createId();
        const subDir = join(baseDir, tempDir);
        mkdirSync(subDir, { recursive: true });

        const pdfPath = `./tmp/${tempDir}/${createId()}.pdf`;
        const imgPath = `./tmp/${tempDir}/${createId()}`;

        await pipeline(
            got.stream(`https://api.telegram.org/file/bot${BOT_TOKEN}/${fileUrl.result.file_path}`),

            createWriteStream(pdfPath)
        );

        if (!existsSync(pdfPath)) {
            return ctx.reply('could not save your file');
        }
        await poppler.pdfToCairo(pdfPath, imgPath, {
            jpegFile: true,
            resolutionXAxis: 72,
            resolutionYAxis: 72,
        });

        const files = await readdir(subDir);

        const jpgFiles = files.filter(
            (file) => file.toLowerCase().endsWith('.jpg') || file.toLowerCase().endsWith('.jpeg')
        );

        ctx.reply(
            "Got your info here, I'm processing it now to add you to my system ðŸ’ª\n\nOne moment Please"
        );

        const base64Images: MessageContent[] = await Promise.all(
            jpgFiles.map(async (file) => {
                const fullPath = join(subDir, file);
                const data = await readFile(fullPath);
                return {
                    type: 'image_url',
                    image_url: {
                        url: `data:image/jpeg;base64,${data.toString('base64')}`,
                        detail: 'auto',
                    },
                };
            })
        );

        const agentRes = await llm({ base64Images });

        console.log({ agentRes });

        const skillsText = agentRes.skills.join(', ');
        const skillsEmbedding = await embeder.embeddings.create({
            model: 'text-embedding-3-small',
            input: skillsText,
            encoding_format: 'float',
        });

        const summaryEmbedding = await embeder.embeddings.create({
            model: 'text-embedding-3-small',
            input: agentRes.summary,
            encoding_format: 'float',
        });

        if (!skillsEmbedding?.data?.[0]?.embedding) {
            throw new Error('Could not generate embeddings for skills');
        }

        if (!summaryEmbedding?.data?.[0]?.embedding) {
            throw new Error('Could not generate embeddings for skills');
        }

        const skillsVec = `[${skillsEmbedding.data[0].embedding.join(',')}]`;
        const summaryVec = `[${summaryEmbedding.data[0].embedding.join(',')}]`;

        const results = await db<SimilarityResult>('job_postings_details')
            .select(
                'id',
                'title',
                'location',
                'compensation',
                'summary',
                db.raw(
                    '((skill_embedding <-> ?::vector(1536)) * 0.75 + (summary_embedding <-> ?::vector(1536)) * 0.25) AS similarity',
                    [skillsVec, summaryVec]
                )
            )
            .orderBy('similarity', 'asc')
            .limit(7);

        const replyItems = results.map(
            (job) =>
                `Title: ${job.title}\nLocation: ${job.location}\nCompensation: ${job.compensation ?? 'N/A'}\nSummary: ${job.summary?.split('.')[0]}`
        );

        console.log(results);

        const replyMessage = `Here's what I found for you!\n\n${replyItems.join('\n\n')}`;

        await ctx.reply(replyMessage);

        // TODO: Inject match feedback into matching. start list of liked jobs and add that into
        //the matching process. every job that got a thumbs up, add that into match
        await rm(subDir, { recursive: true, force: true });
    } catch (e) {
        console.log(e);
    }
});

```

`src/core.ts`:

```ts
import { ok } from 'assert';
import Knex from 'knex';
import got from 'got';
import { toolMap } from './tools.js';
import { systemPrompt } from './prompts.js';
import { resumeSchema } from './schema.js';

export type MessageContent =
    | { type: 'text'; text: string }
    | {
          type: 'image_url';
          image_url: {
              url: string;
              detail: 'auto';
          };
      };

type LlmParams = {
    base64Images?: MessageContent[];
};

const { OPENROUTER_KEY, DB_HOST, DB_PORT, DB_NAME, DB_USER } = process.env;

ok(DB_HOST && DB_PORT && DB_NAME && DB_USER, 'DB env vars must be set');
ok(OPENROUTER_KEY, 'OPENROUTER_KEY MUST BE DEFINED');

const config = {
    client: 'pg',
    connection: {
        host: DB_HOST,
        port: DB_PORT,
        database: DB_NAME,
        user: DB_USER,
    },
};

export async function llm({ base64Images }: LlmParams) {
    if (!base64Images) {
        throw new Error('Must have resume images with request');
    }

    const model = 'google/gemini-2.5-flash-preview';
    const messages: any[] = [
        { role: 'user', content: systemPrompt },
        { role: 'user', content: base64Images },
    ];

    const initialResponse = await got.post('https://openrouter.ai/api/v1/chat/completions', {
        headers: {
            Authorization: `Bearer ${OPENROUTER_KEY}`,
            'Content-Type': 'application/json',
        },
        json: {
            model,
            messages,
            temperature: 0.2,
            top_p: 0.9,
            frequency_penalty: 0.5,
            presence_penalty: 0,
            response_format: {
                type: 'json_schema',
                json_schema: {
                    name: 'analyze_resume',
                    strict: true,
                    schema: resumeSchema,
                },
            },
        },
        responseType: 'json',
    });
    const initialData = initialResponse.body as any;

    const assistantMessage = initialData.choices[0].message;
    messages.push(assistantMessage);

    // Step 2: Handle tool calls if present
    if (assistantMessage.tool_calls) {
        for (const toolCall of assistantMessage.tool_calls) {
            const { id, function: func } = toolCall;
            const args = JSON.parse(func.arguments);
            const toolFn = toolMap[func.name as keyof typeof toolMap];
            if (!toolFn) {
                throw new Error(`Unknown tool: ${func.name}`);
            }
            const result = await toolFn(args);
            messages.push({
                role: 'tool',
                tool_call_id: id,
                name: func.name,
                content: JSON.stringify(result),
            });
        }

        // Step 3: Send the tool result back to the model
        const finalResponse = await got.post('https://openrouter.ai/api/v1/chat/completions', {
            headers: {
                Authorization: `Bearer ${OPENROUTER_KEY}`,
                'Content-Type': 'application/json',
            },
            json: {
                model,
                messages,
            },
            responseType: 'json',
        });

        const finalData = finalResponse.body as any;
        const finalMessage = finalData.choices[0].message;
        return finalMessage;
    } else {
        return JSON.parse(assistantMessage.content);
    }
}

export const db = Knex(config);

```

`src/generateEmbeddings.ts`:

```ts
import 'dotenv/config';
import got from 'got';
import OpenAI from 'openai';
import pLimit from 'p-limit';
import { db } from './core.js';
import type { JobPostingsDetails } from '../types.js';
import assert from 'assert';

const OPENROUTER_KEY = process.env.OPENROUTER_KEY;
const openai = new OpenAI();
const BATCH_SIZE = 3;
const MAX_CONCURRENT_BATCHES = 5;
const BATCH_DELAY_MS = 250;

async function fetchStructuredData(job: JobPostingsDetails) {
    const messages = [
        {
            role: 'user',
            content: `Analyze the job listing and format it in a manner that is compliant with the schema. Do not change anything, do not interpret it whatsoever, just format to the provided schema.\n\nTitle: ${job.title}\nDescription: ${job.text}`,
        },
    ];

    const { body } = await got.post('https://openrouter.ai/api/v1/chat/completions', {
        headers: {
            Authorization: `Bearer ${OPENROUTER_KEY}`,
            'Content-Type': 'application/json',
        },
        json: {
            model: 'google/gemini-2.5-flash-preview',
            messages,
            temperature: 0.2,
            top_p: 0.9,
            frequency_penalty: 0.5,
            presence_penalty: 0,
            response_format: {
                type: 'json_schema',
                json_schema: {
                    name: 'analyze_job',
                    strict: true,
                    schema: {
                        type: 'object',
                        properties: {
                            skills: { type: 'array', items: { type: 'string' } },
                            summary: { type: 'string' },
                        },
                        required: ['skills', 'summary'],
                        additionalProperties: false,
                    },
                },
            },
        },
        responseType: 'json',
    });

    return JSON.parse(body.choices[0].message.content);
}

async function processJob(job: JobPostingsDetails) {
    const structured = await fetchStructuredData(job);
    const [sumRes, skillRes] = await Promise.all([
        openai.embeddings.create({
            model: 'text-embedding-3-small',
            input: structured.summary,
            encoding_format: 'float',
        }),
        openai.embeddings.create({
            model: 'text-embedding-3-small',
            input: structured.skills.join(', '),
            encoding_format: 'float',
        }),
    ]);

    assert(sumRes.data[0], 'missing summary embedding');
    assert(skillRes.data[0], 'missing skill embedding');

    return {
        id: job.id,
        summaryEmbedding: sumRes.data[0].embedding,
        skillEmbedding: skillRes.data[0].embedding,
    };
}

function chunk<T>(arr: T[], size: number): T[][] {
    const res: T[][] = [];
    for (let i = 0; i < arr.length; i += size) {
        res.push(arr.slice(i, i + size));
    }
    return res;
}

async function processBatch(batch: JobPostingsDetails[]) {
    const results = await Promise.all(batch.map(processJob));

    // build VALUES with bindings; JSON.stringify ensures "[...]" literal
    const rowSql = results.map(() => '(?::int, ?::vector, ?::vector)').join(', ');
    const bindings = results.flatMap((r) => [
        r.id,
        JSON.stringify(r.summaryEmbedding),
        JSON.stringify(r.skillEmbedding),
    ]);

    await db.transaction(async (trx) => {
        await trx.raw(
            `
      UPDATE job_postings_details AS j
      SET
        summary_embedding = v.summary_embedding,
        skill_embedding  = v.skill_embedding
      FROM (VALUES ${rowSql})
        AS v(id, summary_embedding, skill_embedding)
      WHERE v.id = j.id
      `,
            bindings
        );
    });

    console.log(`Updated batch IDs: [${results.map((r) => r.id).join(', ')}]`);
    await new Promise((r) => setTimeout(r, BATCH_DELAY_MS));
}

async function processJobs() {
    const jobs = await db('job_postings_details')
        .select('*')
        .whereNull('summary_embedding')
        .orWhereNull('skill_embedding');

    console.log(`Total entries to process: ${jobs.length}`);
    if (!jobs.length) return;

    const batchLimiter = pLimit(MAX_CONCURRENT_BATCHES);
    const batches = chunk(jobs, BATCH_SIZE);

    await Promise.all(batches.map((batch) => batchLimiter(() => processBatch(batch))));
}

try {
    await processJobs();
} catch (e) {
    console.error(e);
    await new Promise((r) => setTimeout(r, 2_500));
    await processJobs();
} finally {
    await db.destroy();
}

```

`src/main.ts`:

```ts
import 'dotenv/config';
import {
    createApp,
    toNodeListener,
    setResponseStatus,
    createRouter,
    defineEventHandler as handler,
} from 'h3';
import { createServer } from 'http';
import { bot } from './bot.js';

const app = createApp();

const router = createRouter();
app.use(router);

router.get(
    '/',
    handler(() => {
        return { message: 'hello' };
    })
);

router.get(
    '/healthcheck',
    handler((evt) => {
        setResponseStatus(evt, 200);
        return { status: 'OK' };
    })
);

await bot.start();

createServer(toNodeListener(app)).listen(3000, '0.0.0.0', () => {
    console.log('Server running on http://0.0.0.0:3000');
});

```

`src/prompts.ts`:

```ts
export const jobEmbedPrompt = `

You are an expert information extractor. Given a full job listing text, extract structured information according to the following schema strictly:

skills: List every explicitly mentioned skill (technologies, methods, tools, or frameworks). Exclude soft skills.

total_experience_years: Extract the minimum number of years of experience required. If a range is given, pick the minimum. If missing, infer 0.

category: Choose the best-fit category from:

- engineer/developer

- designer

- business development

- human resources and people operations

- developer relations

summary: Write a clear, concise 1â€“3 sentence summary capturing the role's main purpose and key responsibilities.

Output JSON matching the schema exactly. No additional commentary.

`;

export const systemPrompt = `
You are an expert resume analyst.

Your task is to extract structured data from a candidate's resume, which may be presented in various formats. Focus on identifying and interpreting content based on its meaning and context, rather than relying on specific section headers or layouts.

Extract the following fields:

- skills: An array of strings representing the candidate's technical skills.
  - Include programming languages, frameworks, libraries, tools, platforms, and services that the candidate has demonstrably used.
  - Exclude vague terms (e.g., "blockchain") unless accompanied by specific technologies (e.g., "Solidity").
  - Normalize names (e.g., "AWS Lambda" â†’ "Lambda") to avoid redundancy.
  - Avoid listing soft skills or general concepts.

- experience: A list of job entries, each containing:
  - title: Job title.
  - company: Company name.
  - start_date: Start date in 'YYYY-MM' format.
  - end_date: End date in 'YYYY-MM' format or 'Present'.
  - duration_months: Total months between start and end dates.
  - responsibilities: An array of strings detailing the candidate's roles, responsibilities, and achievements in each position.

- total_experience_years: Total professional experience, rounded to one decimal place.

- career_level: One of ['entry', 'mid', 'senior', 'executive'], based on experience and job titles.

- category: One of ['engineer/developer', 'designer', 'business development', 'human resources and people operations', 'developer relations'], based on the candidate's background.

- summary: A concise paragraph summarizing the candidate's profile.

Guidelines:

1. Analyze the resume holistically, interpreting content based on context and meaning.
2. Extract skills that are explicitly mentioned and demonstrably used by the candidate.
3. For each experience entry, extract detailed responsibilities and achievements, focusing on quantifiable results and specific contributions.
4. Calculate experience metrics and classify career level logically.
5. For the summary:
   - Synthesize the candidate's professional background, highlighting key skills, notable achievements, and areas of expertise.
   - Provide insights into the candidate's career trajectory, strengths, and potential value to prospective employers.
   - Keep the summary concise, informative, and aligned with the extracted data.
6. Adhere strictly to the specified schema. Do not include additional fields or formatting.
7. Output only plain text. Do not use markdown formatting, including asterisks, hashes, or backticks.

The current year is 2025.

Begin the analysis now.
`;

```

`src/schema.ts`:

```ts
export const jobEmbedSchema = {
    type: 'object',
    properties: {
        skills: {
            type: 'array',
            items: { type: 'string' },
            description: 'List of explicitly mentioned skills.',
        },
        summary: {
            type: 'string',
            description: 'Concise summary of the job description',
        },
    },
    required: ['skills', 'summary'],
    additionalProperties: false,
};

export const resumeSchema = {
    type: 'object',
    properties: {
        skills: {
            type: 'array',
            items: { type: 'string' },
            description: 'List of explicitly mentioned skills.',
        },
        experience: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    title: { type: 'string', description: 'Job title' },
                    company: { type: 'string', description: 'Company name' },
                    start_date: { type: 'string', description: 'Start date (YYYY-MM)' },
                    end_date: { type: 'string', description: "End date (YYYY-MM or 'Present')" },
                    duration_months: { type: 'integer', description: 'Duration in months' },
                    responsibilities: {
                        type: 'array',
                        items: { type: 'string' },
                        description: 'Detailed descriptions of roles and achievements.',
                    },
                },
                required: [
                    'title',
                    'company',
                    'start_date',
                    'end_date',
                    'duration_months',
                    'responsibilities',
                ],
            },
            description: 'Detailed breakdown of job history.',
        },
        total_experience_years: {
            type: 'number',
            description: 'Total years of experience, rounded to one decimal place.',
        },
        career_level: {
            type: 'string',
            enum: ['entry', 'mid', 'senior', 'staff'],
            description: 'Estimated career level based on experience.',
        },
        category: {
            type: 'string',
            enum: [
                'engineer/developer',
                'designer',
                'business development',
                'human resources and people operations',
                'developer relations',
            ],
            description: 'Best-fit job category.',
        },
        summary: {
            type: 'string',
            description: "Concise summary of the candidate's profile.",
        },
    },
    required: [
        'skills',
        'experience',
        'total_experience_years',
        'career_level',
        'category',
        'summary',
    ],
    additionalProperties: false,
};

```

`src/tools.ts`:

```ts
export const toolMap = {
    get_weather: async (args: { city: string }) => {
        // Replace this with your actual weather-fetching logic
        return { temperature: '20Â°C', description: 'Sunny' };
    },
};

export const tools = [
    {
        type: 'function',
        function: {
            name: 'get_weather',
            description: 'Retrieve weather for a city',
            parameters: {
                type: 'object',
                properties: {
                    city: { type: 'string', description: 'City name' },
                },
                required: ['city'],
            },
        },
    },
];

```
